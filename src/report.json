{
  "directories": [
    "pdf_analyzer"
  ],
  "files": [
    "img2pdf_script.py",
    "serialize_dir.py",
    "prefix_files_script.py",
    "pdf_analyzer/__init__.py",
    "pdf_analyzer/pdf_analyzer.py"
  ],
  "file_contents": {
    "img2pdf_script.py": "import img2pdf\nimport sys\nimport os\nfrom pathlib import Path\n\ndef convert_images_to_pdf(input_path, output_pdf):\n    # Ensure the input path is a directory\n    if not os.path.isdir(input_path):\n        print(f\"Error: {input_path} is not a valid directory.\")\n        sys.exit(1)\n\n    # Get all jpg files in the directory\n    jpg_files = [f for f in os.listdir(input_path) if f.lower().endswith('.jpg')]\n    \n    # If no jpg files are found\n    if not jpg_files:\n        print(f\"No JPG files found in the directory: {input_path}\")\n        sys.exit(1)\n    \n    # Create full paths for each image file\n    image_paths = [os.path.join(input_path, f) for f in jpg_files]\n    \n    # Convert the images to PDF using im2pdf\n    try:\n        with open(output_pdf, \"wb\") as output_file:\n            output_file.write(img2pdf.convert(image_paths))\n        print(f\"PDF generated successfully: {output_pdf}\")\n    except Exception as e:\n        print(f\"Error during PDF creation: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    # Ensure the correct number of arguments is provided\n    if len(sys.argv) != 3:\n        print(\"Usage: python im2pdf_script.py <input_folder_path> <output_pdf_path>\")\n        sys.exit(1)\n    \n    input_folder = sys.argv[1]  # Path to the folder containing jpg images\n    output_pdf = sys.argv[2]    # Path to save the output PDF\n    \n    convert_images_to_pdf(input_folder, output_pdf)\n\n",
    "serialize_dir.py": "import os\nimport json\nimport sys\nfrom pathlib import Path\nimport argparse\n\ndef is_hidden_path(path):\n    \"\"\"Check if any part of the path is hidden (starts with .)\"\"\"\n    return any(part.startswith('.') for part in Path(path).parts)\n\ndef serialize_dir(start_path='.'):\n    # Initialize the result dictionary\n    result = {\n        'directories': [],\n        'files': [],\n        'file_contents': {}\n    }\n    \n    # Extensions to read\n    target_extensions = {'.sh', '.toml', '.yml', '.py'}\n    \n    # Convert start_path to absolute path\n    abs_start_path = os.path.abspath(start_path)\n    \n    # Check if directory exists\n    if not os.path.exists(abs_start_path):\n        raise FileNotFoundError(f\"Directory not found: {start_path}\")\n    \n    # Walk through the directory\n    for root, dirs, files in os.walk(abs_start_path):\n        # Remove hidden directories\n        dirs[:] = [d for d in dirs if not is_hidden_path(d)]\n        \n        # Process current directory\n        rel_path = os.path.relpath(root, abs_start_path)\n        if rel_path != '.' and not is_hidden_path(rel_path):\n            result['directories'].append(rel_path)\n        \n        # Process files\n        for file in files:\n            file_path = os.path.join(root, file)\n            rel_file_path = os.path.relpath(file_path, abs_start_path)\n            \n            # Skip hidden files and files in hidden directories\n            if is_hidden_path(rel_file_path):\n                continue\n            \n            # Add to files list\n            result['files'].append(rel_file_path)\n            \n            # Read content of target extensions\n            if any(file.endswith(ext) for ext in target_extensions):\n                try:\n                    with open(file_path, 'r', encoding='utf-8') as f:\n                        result['file_contents'][rel_file_path] = f.read()\n                except Exception as e:\n                    result['file_contents'][rel_file_path] = f\"Error reading file: {str(e)}\"\n    \n    return result\n\ndef main():\n    # Set up argument parser\n    parser = argparse.ArgumentParser(description='Scan directory and create JSON report of files and contents')\n    parser.add_argument('scan_path', help='Relative path to directory to scan')\n    parser.add_argument('output_file', help='Name of the output JSON file')\n    \n    # Parse arguments\n    args = parser.parse_args()\n    \n    try:\n        # Scan the directory\n        result = serialize_dir(args.scan_path)\n        \n        # Write to JSON file in current directory\n        output_path = os.path.join(os.getcwd(), args.output_file)\n        with open(output_path, 'w', encoding='utf-8') as f:\n            json.dump(result, f, indent=2)\n        \n        print(f\"Scan complete! Results written to {output_path}\")\n        print(f\"Found {len(result['directories'])} directories and {len(result['files'])} files\")\n        print(f\"Read contents of {len(result['file_contents'])} files\")\n        \n    except FileNotFoundError as e:\n        print(f\"Error: {e}\", file=sys.stderr)\n        sys.exit(1)\n    except Exception as e:\n        print(f\"Error occurred: {e}\", file=sys.stderr)\n        sys.exit(1)\n\nif __name__ == '__main__':\n    main()\n",
    "prefix_files_script.py": "import os\nimport sys\nimport argparse\nfrom datetime import datetime\nimport glob\n\ndef rename_files(prefix, append_date, pattern):\n    # Get the current date in YYYYMMDD format\n    current_date = datetime.now().strftime(\"%Y%m%d\") if append_date else \"\"\n\n    # Use glob to match files based on the provided pattern\n    files = glob.glob(pattern)\n\n    if not files:\n        print(f\"No files matching pattern '{pattern}' found.\")\n        return\n\n    for file in files:\n        # Create the new filename\n        new_name = f\"{current_date}_{prefix}_{os.path.basename(file)}\" if append_date else f\"{prefix}_{os.path.basename(file)}\"\n\n        # Rename the file\n        try:\n            os.rename(file, new_name)\n            print(f\"Renamed: {file} -> {new_name}\")\n        except Exception as e:\n            print(f\"Error renaming {file}: {e}\")\n\ndef main():\n    # Argument parsing\n    parser = argparse.ArgumentParser(description=\"Rename files by adding a prefix and optionally a date.\")\n    \n    # Prefix argument\n    parser.add_argument(\"-prefix\", required=True, help=\"Prefix to add to the files.\")\n    \n    # Date argument (optional)\n    parser.add_argument(\"-date\", action=\"store_true\", help=\"Append current date (YYYYMMDD) to the filename.\")\n\n    # File pattern argument\n    parser.add_argument(\"pattern\", help=\"Pattern to match the files (e.g., '*.pdf', '*.jpg', etc.).\")\n\n    args = parser.parse_args()\n\n    # Call the rename_files function with parsed arguments\n    rename_files(args.prefix, args.date, args.pattern)\n\nif __name__ == \"__main__\":\n    main()\n\n",
    "pdf_analyzer/__init__.py": "",
    "pdf_analyzer/pdf_analyzer.py": "from openai import OpenAI  # Updated import syntax\nimport PyPDF2\nimport os\nimport sys\nfrom typing import List, Dict, Optional\n\nclass PDFAnalyzer:\n    def __init__(self, api_key: str, categories: List[str]):\n        \"\"\"\n        Initialize the PDF Analyzer with OpenAI API key and categories list.\n        \n        Args:\n            api_key: OpenAI API key\n            categories: List of possible categories (including \"none\")\n        \"\"\"\n        self.categories = categories\n        self.client = OpenAI(api_key=api_key)  # Updated initialization\n        \n    def extract_text_from_pdf(self, pdf_path: str) -> str:\n        \"\"\"\n        Extract text content from a PDF file.\n        \n        Args:\n            pdf_path: Path to the PDF file\n            \n        Returns:\n            str: Extracted text content\n        \"\"\"\n        with open(pdf_path, 'rb') as file:\n            reader = PyPDF2.PdfReader(file)\n            text = \"\"\n            for page in reader.pages:\n                text += page.extract_text() + \"\\n\"\n        return text\n    \n    def analyze_content(self, text: str) -> Dict[str, str]:\n        \"\"\"\n        Analyze the content using OpenAI API to generate description and category.\n        \n        Args:\n            text: Text content to analyze\n            \n        Returns:\n            Dict containing description and category\n        \"\"\"\n        # Create prompt for the AI\n        categories_str = \", \".join(self.categories)\n        prompt = f\"\"\"Analyze the following text and:\n1. Create a brief description (max 100 words)\n2. Categorize it into ONE of these categories: {categories_str}\nIf none of the categories fit, use \"none\"\n\nText to analyze:\n{text[:1000]}...  # Truncate text to avoid token limits\n\nRespond in this format:\nDescription: [your description]\nCategory: [selected category]\"\"\"\n\n        # Call OpenAI API\n        response = self.client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n            temperature=0.3,\n            max_tokens=200\n        )\n        \n        # Parse response\n        response_text = response.choices[0].message.content\n        description = \"\"\n        category = \"\"\n        \n        for line in response_text.split('\\n'):\n            if line.startswith('Description:'):\n                description = line.replace('Description:', '').strip()\n            elif line.startswith('Category:'):\n                category = line.replace('Category:', '').strip()\n        \n        return {\n            'description': description,\n            'category': category\n        }\n    \n    def process_pdf(self, pdf_path: str) -> Dict[str, str]:\n        \"\"\"\n        Process a PDF file: extract text and analyze content.\n        \n        Args:\n            pdf_path: Path to the PDF file\n            \n        Returns:\n            Dict containing the analysis results\n        \"\"\"\n        text = self.extract_text_from_pdf(pdf_path)\n        analysis = self.analyze_content(text)\n        return {\n            'filename': os.path.basename(pdf_path),\n            'description': analysis['description'],\n            'category': analysis['category']\n        }\n\n# Example usage\nif __name__ == \"__main__\":\n    # Define your categories\n    categories = [\"Technical\", \"Financial\", \"Legal\", \"Marketing\", \"Notes\", \"Lesson Plan\", \"none\"]\n    \n    api_key_env = os.getenv(\"API_KEY_OPENAI\")\n    if not api_key_env:\n        print(\"Error: API_KEY_OPENAI environment variable not set\")\n        sys.exit(1)\n\n    # Initialize analyzer with your OpenAI API key\n    analyzer = PDFAnalyzer(\n        api_key=api_key_env,\n        categories=categories\n    )\n\n    # Get path\n    if len(sys.argv) != 2:\n        path_src = \"./document.pdf\"\n        print(f\"no document specified, trying {path_src}\")\n    else:\n        path_src = sys.argv[1]\n    \n    # Process a single PDF\n    result = analyzer.process_pdf(path_src)\n    print(f\"Filename: {result['filename']}\")\n    print(f\"Description: {result['description']}\")\n    print(f\"Category: {result['category']}\")\n    \n    # Process multiple PDFs in a directory\n    def process_directory(directory_path: str) -> List[Dict[str, str]]:\n        results = []\n        for filename in os.listdir(directory_path):\n            if filename.endswith('.pdf'):\n                pdf_path = os.path.join(directory_path, filename)\n                result = analyzer.process_pdf(pdf_path)\n                results.append(result)\n        return results\n"
  }
}